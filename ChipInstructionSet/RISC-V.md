# RISC-V指令集架构

## 2023年信息
```
世界苦Arm久矣，不是因为它不够强大，而是开源更具性价比。RISC-V作为x86、Arm后第三大指令集，备受我国半导体厂商的喜爱。尤其是在MCU领域，过去几年出现过很多RISC-V+Arm双核或纯自研RISV-C内核的MCU产品。
 
前几天，Renesas（瑞萨电子）宣布，推出基于内部自研CPU内核构建的通用32位RISC-V微控制器（MCU）——R9A02G021。

## 从自研到Arm

其实，2007年以前的MCU，自研内核是主流。


最早的微控制器（MCU）要溯源到1971年，那时候，世界上没有MCU这种概念，大家只认为，那是只能驱动计算器的芯片。
 
彼时，Boone和TI（德州仪器）工程师Michael Cochran将处理器、RAM、ROM和I/O都在放在一块硅上，做成了计算器的芯片，也就是TMS1802NC。相隔一年，TI发布了TMS0100计算器系列，将TMS1802NC重新命名为TMS0100家族的第一个成员——TMS0102。
 
一经推出，TMS0100就几乎统治整个计算器市场，不过，TI此时才意识到，如果把这种芯片设计得足够通用，岂不是可以为多个市场服务，征服全世界？因此，1974年，TMS1000微控制器系列才是正式面世，采用了当时主流得哈佛架构。而如今，MCU依旧以其“通用性”，服务着各种场景。
 
随后，半导体界掀起4位MCU风潮，那时候，美国国家半导体公司的COP4XX系列、日本电气公司的PD75XX系列、日本东芝公司TMP47XXX系列等都是当时的典范之作。

此后的二十年，是一个英特尔为主导的MCU时代。
 
1976年9月，英特尔研制出了MCS-48系列8位MCU，相比上述芯片，它的架构更接近现代的MCU。不久后，便将MCS-48系列升级到MCS-51，也就是日后我们所熟悉的“51单片机”，铸就了经典的“51架构”延续至今。

紧接着，Motorola、Zilog、日本电气也跟进M6800系列、Z80系列和μPD78XX系列MCU。
 
1983年，MCU开始步入16位时代，英特尔推出高性能16位MCS-96系列，采用了最新的制造工艺，芯片集成度也刷新了记录，达到12万只晶体管/片。
 
不过，我们都知道，现在的英特尔，并没有MCU业务。那是因为在20世纪80年代中后期，英特尔开始集中精力研发CPU，逐渐放弃MCU生产，并把80C51内核专利或技术转让给飞利浦、日本电气、Atmel、亚德诺、华邦等公司。这不，便开启了80C51百家争鸣的大时代。
 
1990年~2004年，MCU市场开始草长莺飞，百花齐放，一个接一个的自研架构和内核接连浮现。
 
AVR这一8位MCU唯一真神，在1997年由Atrmel研发。紧接着，瑞萨、Motorola的MC68HC系列、TI的MSP430系列等自研架构和内核产品面世。2002年，MIPS又推出M4K内核。
 
2004年，那个“内核”终于来了，Arm推出32位Cortex-M3，这是第一个面向嵌入式微控制器的32位内核。
 
那时候，8位MCU在市场如日中天，飞思卡尔（2015年被恩智浦收购）也推出了32位MCU架构。此时，ST却还没有找到合适的32位架构，而Arm的Cortex-A系列内核在手机领域大获成功，因此与Arm一拍即合。
 
2007年6月，ST向市场推出了32位的STM32系列MCU，这阵风迅速席卷MCU行业，快速取代取代过去的4位、8位、16位MCU。
 
自研内核时代，终于迎来了暂时的终点，直到现在，Cortex-M内核仍然是统治MCU市场的存在。

##  从Arm到RISC-V IP

2010年，开源指令集RISC-V在加州大学伯克利分校诞生，横插一道的它，刚开始并没有引起太多人关注。


直到2019年，兆易创新携手芯来科技，推出全球首款基于RISC-V的Bumblebee处理器内核的GD32V系列通用单片机——GD32VF103。此时，行业又掀起了一拨采用RISC-V IP内核的风潮。

彼时，大多数公司的战略都是“坚持Arm和RISC-V两种架构并行”。
 
那个时期，出现的典型产品包括搭载芯来科技N100系列的中微半导体ANT32RV56xx，搭载芯来RISC-V处理器N203+Arm Cortex-M3的航顺HK32U1xx9，搭载芯来科技N308内核的中移芯昇（中国移动旗下专业芯片子公司）CM32M4xxR。
 
异军突起的RISC-V虽然免去了指令集授权之苦，但说白了，这时候还是要买别人做好的RISC-V IP。
 
比如说，放在MCU中的典型RISC-V IP包括晶心科技N22/N25F/D25F/N45/D45系列、芯来科技N100/N200/N300/N600/N900系列、赛昉科技E内核系列、平头哥E902系列、中关村芯园 SAR-T6系列。
 
把这些IP放进MCU，还是要给设计IP的公司付钱。专业的IP工作交给专业的IP公司，其实是很好的路。但想把MCU做得更具特色，免去一切授权的烦恼，就要自研RISC-V内核。

面对芯片IP行业日新月异的局势，不少芯片大厂都对新的设计架构跃跃欲试，也就是自己做RISC-V内核。
 
早在2022年，就有消息透露，瑞萨要开始自研RISC-V内核。2023年11月30日，瑞萨电子发布了其专有的32位RISC-V内核，引起了半导体行业关注。2024年3月26日，瑞萨基于内部自研CPU内核构建的通用32位RISC-V微控制器（MCU）——R9A02G021正式面世。
 
在过去，瑞萨推出了采用晶心科技RISC-V内核的产品，如32位语音控制ASSP、电机控制ASSP和64位通用微处理器“RZ/Five”。这一次，瑞萨自研的RISC-V内核，则能够适用于许多不同的应用环境。它可以用作主 CPU 或管理片上子系统，甚至嵌入到专门的ASSP（特定应用标准产品）设备中，简单解释，就是更通用、更灵活。
 
可以说，从授权倒戈自研，这会是趋势，也会是行业走向百花齐放的又一标志。

## 自研RISC-V大时代

 
面对芯片IP行业日新月异的局势，不少芯片大厂都对新的设计架构跃跃欲试，也就是自己做RISC-V内核。
 
早在2022年，就有消息透露，瑞萨要开始自研RISC-V内核。2023年11月30日，瑞萨电子发布了其专有的32位RISC-V内核，引起了半导体行业关注。2024年3月26日，瑞萨基于内部自研CPU内核构建的通用32位RISC-V微控制器（MCU）——R9A02G021正式面世。
 
在过去，瑞萨推出了采用晶心科技RISC-V内核的产品，如32位语音控制ASSP、电机控制ASSP和64位通用微处理器“RZ/Five”。这一次，瑞萨自研的RISC-V内核，则能够适用于许多不同的应用环境。它可以用作主 CPU 或管理片上子系统，甚至嵌入到专门的ASSP（特定应用标准产品）设备中，简单解释，就是更通用、更灵活。
 
可以说，从授权倒戈自研，这会是趋势，也会是行业走向百花齐放的又一标志。

反观国内，一直都颇为注重自研RISC-V内核，想做出差异化的产品。
 
沁恒微电子是国内第一批基于自研RISC-V内核构建芯片、共建生态并实现产业化的芯片公司。青稞处理器是沁恒微电子自研的32位RISC-V微处理器，
 
乐鑫科技成功自研RISC-V处理器，并应用在ESP32-C和ESP32-H系列芯片中，包括ESP32-C2、ESP32-C3、ESP32-C5、ESP32-C6、ESP32-H2。并持续投入RISC-V研发，推出更多搭载RISC-V处理器的产品
 
2023年12月，上海海思披露了公司聚焦行业专用（Application Specific）和嵌入式AI技术（Artificial Intelligence）的A²MCU。其中，Hi3065H是基于海思自研RISC-V内核的高性能实时控制专用MCU， 具有高性能、高集成度、高可靠性、易开发的特点，同时配合海思强大的算法团队和嵌入式AI能力，使得Hi3065H上市后快速获得家电、能源、工业等行业内多个客户的认可和好评。

## 自研内核，还是要看市场

MCU自研内核，究竟是不是个好生意？
 
从数据来看，RISC-V MCU的市场，没有高端RISC-V市场香，比如说高性能计算、汽车、手机、服务器等。
 
RISC-V MCU出货量，在整个RISC-V SoC中一直是量最大的。SHD group的数据显示，2022年，RISC-V SoC的总市场在2022年为5.36亿台，预计在2023年将达到12.6亿台。其中MCU出货量最大，将近占据整个市场的一半，2022年达到3.67亿台，2023年可达6.17亿台，其次是AI加速器和存储控制器。
 
不过，RISC-V MCU整体收入并不及AI加速器（2022年10.7亿美元，2023年26亿美元），2022年为3.6亿美元，到2030年，RISC-V MCU市场可达72亿美元，复合年增长率为42.0%。

所以，这几年RISC-V一直在大力向高端市场推进，MCU的量虽大，但单个产品价格还是没有优势。
 
也就是说，自研RISC-V内核还是授权IP，还是要看自己所针对的应用，有没有那么大的市场拓展空间。
 
根据SHD group的分析，目前消费市场是RISC-V MCU最大的市场，其次是网络和计算，而基于RISC-V的MCU预计将在汽车领域得到大量且不断增长的使用。

 
```


## 一种低开销高性能的 RISC-V 处理器设计

目前典型的RISC-V处理器有 Rocket、BOOM[2]、RI5CY、Zero-riscy、Micro-riscy等.

Rocket是一款5流水线、单发射、顺序执行的64位处理器，BOOM是一款64位超标量、乱序执行的处理器, 这两款处理器与ARM Cortex-A系列产品在性能和面积的比较中显示出了较大的竞争力[3]。

RI5CY、Zero-riscy和Micro - riscy均是由 ETH Zurich配套开发的RISC-V处理器，主要面向超低功耗、超小面积的场景[4]。

### WCH_V4A 总体架构
不同于经典的5级流水线，本文使用了结构更简单、功耗更低的3级流水线结构，分别为取指、译码和执行。其中取指级主要完成指令预取、压缩指令扩展和分支预测。译码级主要完成指令的译码、冲突检测、操作数读取以及指令发射。执行级则对指令进行执行以及回写，同时访存也在这一级流水线中完成。本文通过对比WCH V4A和BOOM（一种高性能多发射、乱序执行处理器）[2]的结构，突出显示了WCH_V4A在架构上实现高性能、低开销的可能性。

![](https://raw.githubusercontent.com/LeroyK111/pictureBed/master/640)
**图1** **WCH_V4A****（实线框表示）和****BOOM****（虚线框）架构示意图**

图1为WCH_V4A和BOOM的简化架构图，其中实线部分为WCH_V4A中存在的单元，虚线部分为BOOM 新增加的单元。图1所示，BOOM采用了更宽的指令总线，以及重复的译码、发射、执行电路。因此BOOM不仅需要更大的存储器带宽，而且必须加快处理器内部的数据处理速度，以此达到更高的性能。WCH_V4A的取指和译码均为单通道，以32位的方式和存储器交换数据，此时取指和译码单元均可以得到充分利用，同时WCH_V4A 允许指令进行乱序执行，多周期和单周期的指令可以并行地在执行单元中运行，最后WCH_V4A采用双端口回写的方式对指令的回写进行加速。因此，WCH_V4A通过顺序取指、乱序执行、乱序回写的策略平衡了处理器内部的各个单元，从而达到面积、功耗和性能的折中。

### **WCH_V4A 流水线架构**

#### **取指单元**       
如图2所示，WCH_V4A的取指单元主要由地址生成器（AGU）、AHB控制器（AHB CTRL）、指令 FIFO（IN-STR FIFO）、压缩指令扩展单元（CIEU）、分支预测单元构成。地址生成器用于产生指令PC，并将取指请求发送给AHB控制器和存储器保护单元（PMU）。为了支持混合长度编码（即支持压缩指令），从指令总线返回的数据需要送入指令FIFO 中进行移位和拼接处理，同时为了更高效的数据传递，指令FIFO中加入了旁路输出电路。指令FIFO每次输出一条有效指令到压缩指令扩展单元(CIEU)，CIEU会对压缩指令进行检测并扩展为普通的32位指令。CIEU为单输出通道，输出的指令一方面送入到分支检测单元中（Branch Scan）进行分支指令的相关检测，另一方面则传递至下一级流水线进行数据处理。

![](https://raw.githubusercontent.com/LeroyK111/pictureBed/master/20241123203000.png)

从图2中可以看出，WCH_V4A在取指单元中加入了指令FIFO，允许指令的预取，同时加入了旁路输出电路，加快了数据流的处理效率。同时，分支预测单元位于WCH_V4A的第一级流水线，这样做可以减少分支指令造成的流水线气泡。如图2所示，分支预测单元由分支预测缓存（BTB）、分支预测历史表（BHT）、返回地址栈（RAS）构成。目前处理器领域广泛应用的动态分支预测技术主要有Bimodal预测器[4]、两级自适应预测器[5]、Gshare预测器[6]、Hybrid 预测器等。分支预测器的准确度越高，其处理器性能则越高，但是其硬件复杂度也越大。性能与复杂度的折中是WCH_V4A设计的出发点，相关研究表明，Gshare预测器在性能和复杂度折中上具有优秀的表现[7]，因此WCH_V4A选择了Gshare 预测器作为分支预测的主要单元。  

Gshare算法基本的框架如图3所示。通过分支地址的n-bit和全局分支历史移位寄存器的n-bit进行杂凑(hash）运算（即位异或运算）,所得的结果用来索引2n项模式表，每一项模式表中包含2位饱和计数器。其中00代表强不跳转、01代表弱不跳转、10代表弱跳转、11代表强跳转。若索引结果为弱跳转或者强跳转，则分支预测为跳转，否则为不跳转。全局分支历史移位寄存器对于预测结果的准确性至关重要，它包含了过去的n次分支指令的结果。在WCH_V4A中Gshare预测器位于第一级流水线，这意味着当一条分支指令处于预测阶段时，在后几级流水线中可能存在着没有解析的分支指令。为了对连续分支指令的准确预测，WCH_V4A中对Gshare中的全局分支历史移位寄存器同样进行预测，并采用预测的值和PC进行杂凑运算，以此作为PHT的索引。

![](https://raw.githubusercontent.com/LeroyK111/pictureBed/master/20241123203108.png)

WCH_V4A的动态预测器对RISC-V32I的跳转指令均进行了检测，并根据其操作数和操作码的不同分成了以下几类：立即数相对跳转（JumpI)、寄存器相对跳转(JumpR)、函数返回（Return)、条件跳转（Branch)。其中JumpI使用PC与IMM（指令编码中的立即数）的和作为预测结果，JumpR使用BTB的预测结果，Return使用RAS的预测结果，ranch则使用BHT的预测结果。

#### **译码单元**       

如图4所示，WCH_V4A的译码单元主要由译码器（Decoder）、读操作数单元（ROU）、冲突检测单元（HDU）、计分板（Scoreboard）、发射单元（ISU）、指令退役单元（IRU）、通用寄存器单元构成。首先，译码器对指令进行译码，并将结果分别送入ROU、HDU、ISU。ROU中主要进行操作数的读取，WCH_V4A采用了前递技术（For-warding），功能单元中返回的数据前递至ROU单元，以此来加快数据的处理速度。HDU 单元利用Scoreboard 单元中保存的指令数据和状态进行冲突的检测。准备就绪的指令则通过ISU单元发射给执行单元，同时在Scoreboard中记录指令数据和状态，至此一条指令的译码阶段完成，并将等待功能单元返回的数据进行指令的回写和退役。

![](https://raw.githubusercontent.com/LeroyK111/pictureBed/master/20241123203221.png)

目前，许多高性能处理器会加入保留站和重命名技术[2]，同时将译码级分成读取操作数和发射两个步骤，这种方法不仅可以对数据冲突进行检测同时还可以消除部分冲突，但是相应地会增加控制逻辑的复杂度，同时也增加了动态功耗。出于对最高能效比的设计初衷，WCH_V4A使用了简化的算法，只对数据冲突进行检测，允许没有相关性的指令进行乱序执行，有相关性的指令则采用流水线停顿的方式进行保护。此外，不断发展的编译技术可以利用静态调度的方式，分开具有相关性的指令来使冲突数量和性能损失降到最低程度。

#### **执行单元**       

如图5所示，WCH_V4A的执行单元主要由一系列的功能单元、AHB控制单元、控制流单元（CFU）、写回仲裁单元等构成。译码过后的指令经过发射单元将操作码、操作数送给相应的功能单元执行，为了提高性能，执行单元最多可以有3条指令并发执行。控制流单元则主要用于处理预测失败、异常、FENCEI、FENCE、WFI等程序流的控制。为了完成乱序回写的功能，有些处理器的设计中加入了重排序缓存单元（ROB）[2]或者使用统一的物理寄存器组。使用ROB的方案则会增加面积，同时由于需要写回两次（先写回ROB，再写回RegFile）而增加了动态功耗。使用统一的物理寄存器组则需要动态管理物理寄存器组的映射关系，因此也需要更复杂的控制逻辑。WCH_V4A 中采用了双端口乱序回写的策略，一方面有相关性的指令在译码单元就已经通过流水线暂停的方式保护起来，完成乱序回写只需要简单的逻辑即可完成；另一方面得益于简单的流水线结构和控制逻辑，通用寄存器写端口上的时序路径较短，因此双端口的回写策略将以较少的资源换取较大的性能提升。

![](https://raw.githubusercontent.com/LeroyK111/pictureBed/master/20241123203400.png)

#### **稳定性**       

处理器的稳定性对于任何一款产品来说都是至关重要的，WCH_V4A使用Verilog实现，并使用了软硬件结合的验证方式进行功能性和稳定性的验证，并通过了所有的测试。同时WCH_V4A中内嵌了符合RISC-V调试手册的调试模块，并使用自定义的2线调试接口进行代码的下载和调试。为了更好地面向嵌入式设备，WCH_V4A 为每个外部中断均设置了独立入口，同时具有多级嵌套机制和快速中断响应机制。此外，对于非精确异常（如读写存储器出错）,WCH_V4A做了保护机制。如果需要精确定位则可以采用流水线暂停的模式进行访存操作，这将会损失一定的性能，但是能够保证在访存失败后处理器内部的状态不被后面的指令更新（WCH_V4A 为乱序执行处理器）。如果不需要精确定位，则可以采用全速模式进行访存操作，此时处理器将会以高性能模式运行。


### Benchmarks

#### **插入排序**       

对于少量元素的排序，插入排序是一个有效的算法。它的基本思想是将一个记录插入到已经排好序的有序表中，变成一个新的、记录数增1的有序表。在其实现过程中使用双层序号，外层循环对除了第一个元素外的所有元素，内层循环对当前元素前面有序表进行待插入位置查找，并进行移动[10]。  

本文对插入排序在不同的指令集架构下进行编译，并对比了它们的指令数量和代码大小。其结果如图6所示，在RV32I、RV32IC、ARM-32中指令数量均为19条，ARM Thumb-2中则为18条，MIPS-32、microMIPS、x86-32分别为24、24、20条指令。从代码空间上对比，x86-32和ARM Thumb-2具有一定的优势，分别为45和46字节。具备压缩指令的RISC-V设备则将代码空间由76字节缩小到了52字节，节约了大约32％的代码空间。

![](https://raw.githubusercontent.com/LeroyK111/pictureBed/master/20241123203736.png)

为了反映处理器对插入排序的执行效率，本文采用两款ARM Cortex-M3为核心的产品CH32F103和STM32F103,与WCH_V4A进行了对比。其中 CH32F103、STM32F103、WCH_V4A 均采用相同存储器访问方式，同时数据和指令总线互相独立（三者均使用AMBA-AHB总线接口协议）。

实验结果如表1所列。
![](../readme.assets/Pasted%20image%2020241123203804.png)
对数据的分析显示，CH32F103和STM32F103对插入排序算法的处理速度基本一致，均可以代表 ARM Cor-tex-M3对插入排序的执行效率，WCH_V4A则显示出了较高的处理速度，其中在﹣O3 和最佳性能的编译选项下，WCH_V4A对256大小的数组使用插入排序进行逆排序的处理时间与STM32F103和CH32F103相比，分别缩短了33％和46.7%。实验结果表明，以WCH_V4A为核心的产品在插入排序算法的执行效率上比以 ARM Cortex-M3为内核的产品表现出了更优异的性能。

#### **Dhrystone/Coremarks**              
Dhrystone 和 Coremarks 均是用来测试CPU整数计算性能的基准程序，广泛应用于嵌入式处理器的性能评估。本文对CH32F103（ARMCortex-M3）和WCH_V4A 分别做了 Dhrystone 和 Coremarks 的测试。实验结果如表2所列，对比数据可知，WCH_V4A在跑分测试程序中的表现比CH32F103更为优异，Dhrystone和Coremarks 在Max option（最佳性能）选项下分别提升了11.0％和13.4%，在﹣O3选项下，提升了100.0％和56.2%。实验结果表明，WCH_V4A在多种处理器性能基准测试程序中均比以ARM Cortex-M3为内核的产品的表现更为突出。
![](https://raw.githubusercontent.com/LeroyK111/pictureBed/master/20241123203905.png)

